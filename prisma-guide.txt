// This is a comprehensive Prisma schema demonstrating various features.

// 1. Data Source Block: Defines the database connection.
//    - 'provider': Specifies the database type (e.g., "postgresql", "mysql", "sqlite", "sqlserver", "mongodb", "cockroachdb").
//    - 'url': Connection string, typically from an environment variable for security.
//    - 'shadowDatabaseUrl': (Optional) Used by Prisma Migrate for development.
//    - 'directUrl': (Optional) Used for direct connections by Prisma CLI if 'url' points to a connection pooler.
datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // Used by prisma migrate dev
  directUrl         = env("DIRECT_DATABASE_URL") // For connection poolers like PgBouncer
  // relationMode = "prisma" // Optional: Enforces referential integrity in Prisma Client (Preview)
  // extensions = ["uuid-ossp", "citext"] // PostgreSQL specific extensions (Preview)
}

// 2. Generator Block: Defines what client to generate.
//    - 'provider': "prisma-client-js" is the most common for Node.js/TypeScript.
//    - 'output': (Optional) Specifies where the generated client should be placed.
//    - 'previewFeatures': Enables experimental features.
//    - 'binaryTargets': (Optional) For specific runtime environments.
generator client {
  provider        = "prisma-client-js"
  output          = "../node_modules/@prisma/client" // Custom output path
  previewFeatures = ["fullTextSearch", "multiSchema"] // Example preview features
  // binaryTargets = ["native", "linux-arm64-openssl-3.0.x"] // For specific deployment targets
  // runtime = "nodejs" // Specify runtime environment (node, deno, bun, etc.)
}

// 3. Enums: Define a set of allowed string values.
//    - Mapped to native ENUM types in PostgreSQL/MySQL or validated strings in other DBs.
enum Role {
  USER
  ADMIN
  EDITOR
  GUEST @map("guest_user") // @map attribute for enum values
}

enum Status {
  PENDING
  APPROVED
  REJECTED
  ARCHIVED
}

// 4. Models: Represent your database tables/collections.

/// @/// This is a documentation comment for the User model.
/// It appears in the generated Prisma Client.
model User {
  // Scalar Fields: Basic data types

  // Primary Key (id): Uniquely identifies each record.
  // @id: Marks the field as the primary key.
  // @default(uuid()): Automatically generates a UUID for new records (common for String IDs).
  id        String   @id @default(uuid()) @map("_id") // @map: Maps the field name to a different database column name.
  createdAt DateTime @default(now()) @map("created_at") // @default(now()): Sets the current timestamp on creation.
  updatedAt DateTime @updatedAt // @updatedAt: Updates timestamp on every record modification.

  email String @unique // @unique: Ensures values are unique across all records.
  // @db.VarChar(255): Native database type attribute for PostgreSQL.
  // Allows specifying the exact database column type for more control.
  username String @unique @db.VarChar(100)
  passwordHash String @map("password_hash") // Useful for storing hashed passwords.

  name       String? // Optional field (can be null).
  age        Int?    @map("user_age")
  // @default(dbgenerated()): For default values generated by the database.
  bio        String? @db.Text // @db.Text for larger text fields in PostgreSQL
  isActive   Boolean @default(true)
  balance    Decimal @default(0.00) @db.Money // Example of Decimal and a native type for currency
  rating     Float?  // Can be Float or Double
  birthDate  DateTime? @db.Date // Store only date, no time (PostgreSQL specific)
  // jsonField Json? // For JSON type in PostgreSQL/MySQL/MongoDB

  // Enum Field: Uses the defined 'Role' enum.
  role Role @default(USER)

  // Relation Fields: Define connections between models.
  // One-to-many relation: One User can have many Posts.
  // 'Post[]' indicates a list of Post records.
  posts Post[]

  // One-to-one relation: One User can have one Profile.
  // 'Profile?' indicates the relation is optional.
  profile Profile?

  // Many-to-many (Implicit): A User can participate in many chats, and a Chat can have many Users.
  // Prisma manages the join table automatically for relational databases.
  chats Chat[]

  // Self-relation (One-to-many): User can have followers and follow other users.
  followers User[] @relation("UserFollows") // Users who follow this user
  following User[] @relation("UserFollows") // Users this user is following

  // Block Attributes: Apply to the entire model.
  // @@map("app_users"): Maps the Prisma model name 'User' to a different database table name.
  @@map("app_users")
  // @@unique([username, email]): Creates a compound unique constraint.
  @@unique([username, email])
  // @@index([email]): Creates a non-unique index on the email field for faster lookups.
  @@index([email])
  // @@fulltext([username, name]) // Full-text search index (Preview, often for MySQL/MongoDB)
  // @@schema("app_schema") // For multi-schema support in PostgreSQL (Preview)
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  // One-to-one relation back to User.
  // @relation: Defines the relation.
  //   - 'fields': The foreign key field(s) in this model.
  //   - 'references': The primary key field(s) in the related model.
  //   - 'onDelete', 'onUpdate': Referential actions (CASCADE, SET_NULL, RESTRICT, NO_ACTION, SET_DEFAULT).
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String  @unique // Foreign key. @unique ensures one-to-one.
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String
  content   String? // Optional field
  published Boolean  @default(false)
  viewCount Int      @default(0)

  // One-to-many relation: A Post belongs to one User (author).
  author   User   @relation(fields: [authorId], references: [id])
  authorId String // Foreign key to User.id

  // Explicit Many-to-Many Relation: Posts can have many Categories, Categories can have many Posts.
  // This requires an explicit join table (PostCategory) model.
  categories PostCategory[] // This post's categories (through the join table)

  // Many-to-many (Implicit): Post can have many Tags, Tag can be on many Posts.
  // Prisma manages the join table.
  tags Tag[]

  status Status @default(PENDING) // Enum field

  @@index([published, createdAt]) // Compound index
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String @unique
  slug  String @unique @db.VarChar(100)

  // Relation to the explicit join table
  posts PostCategory[] // Posts in this category (through the join table)

  @@index([name])
}

// Explicit Many-to-Many Join Table Model
// Represents the `_PostToCategory` table in the database if using implicit.
// Here, we explicitly define it to allow for additional fields on the join table.
model PostCategory {
  postId     Int
  categoryId Int
  assignedAt DateTime @default(now()) // Additional field on the join table

  post Post @relation(fields: [postId], references: [id])
  category Category @relation(fields: [categoryId], references: [id])

  @@id([postId, categoryId]) // Composite primary key for the join table
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique
  posts Post[] // Implicit many-to-many relation
}

model Chat {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  title     String?
  messages  Message[] // One-to-many relation to Message
  users     User[] // Implicit many-to-many relation with User
}

model Message {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  content   String
  // Relation to the Chat model
  chat      Chat     @relation(fields: [chatId], references: [id])
  chatId    Int
  // Relation to the User model (who sent the message)
  sender    User     @relation(fields: [senderId], references: [id])
  senderId  String
}

// Composite Types (MongoDB Only - for Relational DBs, consider separate models or JSON fields)
// This model would only be valid if `provider = "mongodb"` in `datasource db`.
/*
type Address {
  street  String
  city    String
  zipCode String
  country String
}

model Order {
  id            String    @id @default(auto()) @map("_id") @db.ObjectId
  createdAt     DateTime  @default(now())
  totalAmount   Decimal
  shippingAddress Address   // Embedded document/composite type
  billingAddress  Address?  // Optional embedded document
  items         OrderItem[] // List of composite types
}

type OrderItem {
  productId String @db.ObjectId
  quantity  Int
  price     Decimal
}
*/

// Example of a View (PostgreSQL specific, defined using raw SQL in migrations)
// Prisma can "see" views through introspection, but you define their schema
// similar to models. You cannot migrate/push views directly from Prisma schema.
// model PublishedPostView {
//   id        Int      @id
//   title     String
//   content   String?
//   authorName String? @map("author_name")
//   // @@map("published_posts_view") // Maps to your view name
//   // @@ignore // Prisma will ignore this model during migrations/pushes if you want to manage it manually
// }


// 5. Raw SQL functionality (not directly in schema, but important to know)
//    - Prisma ORM also allows you to execute raw SQL queries via `prisma.$queryRaw` and `prisma.$executeRaw`
//      for operations not covered by Prisma Client or for custom database features like stored procedures,
//      triggers, or more complex views.

// 6. Comments
//    - `///` comments are included in the generated client as JSDoc.
//    - `//` comments are for schema readability and are ignored by the generator.